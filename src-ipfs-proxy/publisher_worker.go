package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
)

type TaskStatus uint8

const (
	TaskPending TaskStatus = iota
	TaskProcessing
	TaskFinished
)

type PublishTask struct {
	Id       string // Publish ID generated by caller
	PubKey   string // IPFS key used for publishing the IPFS path
	IpfsPath string

	CreatedAt  int64 // Task created millisecond
	FinishedAt int64 // Task published millisecond, not using for now
}

type PublisherWorker struct {
	IpfsRpcAddr string
	MsgCh       *chan *PublishTask

	CheckInterval     time.Duration
	TaskExpiredSecond int

	taskPoolLock sync.Mutex
	taskPool     map[string]PublishTask
	ipnsMapping  map[string]string

	ipfsClient *fiber.Client
}

// NewPublisherWorker Create PublisherWorker with default config
// TODO: Change to singleton mode
func NewPublisherWorker(ipfsRpcApiAddr string) *PublisherWorker {
	return &PublisherWorker{
		IpfsRpcAddr:       ipfsRpcApiAddr,
		CheckInterval:     2 * time.Second,
		TaskExpiredSecond: 60 * 60, // Task will be expired after 60 minutes
		ipnsMapping:       map[string]string{},
		taskPool:          map[string]PublishTask{},
		ipfsClient:        fiber.AcquireClient(),
	}
}

// Start function starts the publishing and clean task
func (p *PublisherWorker) Start() {
	wg := &sync.WaitGroup{}
	go p.processPublishTask(wg)
	wg.Wait()
}

// AddTask creates a task object with timestamp
func (p *PublisherWorker) AddTask(pubKey, ipfsPath string) string {
	task := PublishTask{
		Id:         uuid.NewString(),
		PubKey:     pubKey,
		IpfsPath:   ipfsPath,
		CreatedAt:  time.Now().UnixMilli(),
		FinishedAt: 0,
	}

	p.taskPoolLock.Lock()
	defer p.taskPoolLock.Unlock()
	p.taskPool[ipfsPath] = task
	return task.Id
}

// Convert task into API call and send to IPFS server
func (p *PublisherWorker) processPublishTask(wg *sync.WaitGroup) {
	wg.Add(1)
	ticker := time.NewTicker(p.CheckInterval)

	for {
		select {
		case <-ticker.C:
			pendingTasks := map[string]PublishTask{}
			p.taskPoolLock.Lock()
			// Move all tasks to new created one and clear original task map
			for k, v := range p.taskPool {
				pendingTasks[k] = v
			}
			p.taskPool = map[string]PublishTask{}
			p.taskPoolLock.Unlock()

			for _, task := range pendingTasks {
				go p.doPublish(&task)
			}
		}
	}
}

func (p *PublisherWorker) doPublish(task *PublishTask) {
	publishUrl := fmt.Sprintf("%s/api/v0/name/publish?arg=%s&key=%s", p.IpfsRpcAddr, task.IpfsPath, task.PubKey)
	a := p.ipfsClient.Post(publishUrl)
	if err := a.Parse(); err != nil {
		panic(err)
	}

	code, body, errs := a.Bytes()

	if len(errs) > 0 {
		log.Printf("Invoke IPFS publish error: %+v\n", errs)
	}

	if code == http.StatusOK {
		p.taskPoolLock.Lock()
		defer p.taskPoolLock.Unlock()

		respData := map[string]string{}
		err := json.Unmarshal(body, &respData)
		if err != nil {
			log.Printf("error occurred while parsing publish result")
			return
		}

		if publishName, found := respData["Name"]; found {
			p.ipnsMapping[task.Id] = publishName
		}
	}
}

// TaskIpnsPath returns IPNS name for publish task
func (p *PublisherWorker) TaskIpnsPath(taskId string) string {
	if taskIpnsName, found := p.ipnsMapping[taskId]; found {
		return fmt.Sprintf("/ipns/%s", taskIpnsName)
	} else {
		return ""
	}
}
